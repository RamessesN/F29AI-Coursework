\documentclass[12pt,a4paper]{article}

%----------------------------------------------------------------------------------------
% PACKAGES
%----------------------------------------------------------------------------------------
\usepackage[a4paper,margin=25mm]{geometry}
\usepackage{fontspec}
\setmainfont{Times New Roman}

\usepackage{amsmath}
\usepackage{graphicx,float,booktabs,array,multirow,url}
\usepackage{gensymb}
\usepackage[british]{babel}
\usepackage[square,numbers,sort&compress]{natbib}
\usepackage{caption,subcaption}
\usepackage{pgfplots}
\pgfplotsset{compat=1.9}
\usepackage{xurl}

\usepackage[colorlinks=true,
            linkcolor=blue,
            citecolor=blue,
            urlcolor=blue]{hyperref}

\usepackage{minted}

\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\addtolength{\topmargin}{-2.5pt}

\usepackage{silence}
\WarningFilter{gensymb}{Not defining}

%----------------------------------------------------------------------------------------
% CUSTOM ABSTRACT FORMAT
%----------------------------------------------------------------------------------------
\makeatletter
\renewenvironment{abstract}{
    \begin{quote}\small \centering
}{
    \end{quote}
}
\makeatother

%----------------------------------------------------------------------------------------
% USER INFORMATION
%----------------------------------------------------------------------------------------
\newcommand{\studentonename}{Keqin ZHANG}
\newcommand{\studenttwoname}{Yuwei ZHAO}
\newcommand{\studentonenumber}{H00460395}
\newcommand{\studenttwonumber}{H00460398}
\newcommand{\labgroup}{OUC CW1 33}
\newcommand{\labdate}{2025-11-10}
\newcommand{\course}{F29AI - Artificial Intelligence}
\newcommand{\labtitle}{CW1 Report}

%----------------------------------------------------------------------------------------
% TITLE
%----------------------------------------------------------------------------------------
\title{
    \vspace{-1cm}
    \textbf{\labtitle}\\[0.3em]
    \Large \course
}
\author{
    \studentonename~(\studentonenumber)
    \quad
    \studenttwoname~(\studenttwonumber) \\[0.5em]
    \labgroup \quad \labdate
}
\date{}

%----------------------------------------------------------------------------------------
% PAGE STYLE
%----------------------------------------------------------------------------------------
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\labtitle}
\fancyhead[C]{\course}
\fancyhead[R]{\labgroup}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

\setlength{\parindent}{0em}
\setlength{\parskip}{0.75em}

%----------------------------------------------------------------------------------------
% DOCUMENT BODY
%----------------------------------------------------------------------------------------
\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
% ABSTRACT
%----------------------------------------------------------------------------------------
\begin{abstract}
    \textbf{\textit{Note}}: See Resources on \href{https://github.com/ZhangKeqin0307/couresework1.git}{git@github.com:ZhangKeqin0307/couresework1.git}.
\end{abstract}

%----------------------------------------------------------------------------------------
% SECTION 1
%----------------------------------------------------------------------------------------
\section{Part 1 - \textit{Sudoku} Puzzels}
%----------------------------------------------------------------------------------------
\subsection{Part 1A}
%----------------------------------------------------------------------------------------
\subsubsection{Procedure}
%----------------------------------------------------------------------------------------
\label{subsection:Procedure}
A CSP(constraint satisfaction problem) \cite{csp_ref} should involve the following three components: Variables, Domains and Constraints.
Therefore, we can define the Sudoku problem as follows:
\[
\text{Sudoku} = \langle V, D, C \rangle
\]
where
\begin{itemize}
    \item $V$: The set of 81 variables, $V = \{V_{i,j} \mid i,j \in \{1, 2, \ldots, 9\}\}$.
    
    \item $D$: The domain $D_{i,j}$ for each variable $V_{i,j}$ is defined as:
    \begin{equation}
        \begin{cases}
            D_{i,j} = k, & \text{if } V_{i,j} \text{ is a given cell with value } k, \\
            D_{i,j} = \{1, 2, \ldots, 9\}, & \text{if } V_{i,j} \text{ is an empty cell}.
        \end{cases}
        \nonumber
    \end{equation}

    \item $C$: The set of 27 (9 rows + 9 columns + 9 subgrids) all-different constraints:
    \begin{equation}
        \begin{cases}
            C_{\text{row}}: & \text{Each row } i \text{ contains 9 different values}, \\
            C_{\text{col}}: & \text{Each column } j \text{ contains 9 different values}, \\
            C_{\text{subgrid}}: & \text{Each } 3 \times 3 \text{ subgrid contains 9 different values}.
        \end{cases}
        \nonumber
    \end{equation}
\end{itemize}

%----------------------------------------------------------------------------------------
\subsubsection{Time Complexity Analysis}
%----------------------------------------------------------------------------------------
\begin{enumerate}
    \item \textbf{Brute-force Search Algorithm} \cite{bruteforce_ref} : \\
    For each of the $k$ spaces, there are 9 possible choices of numbers. This results in a total of $9 \times 9 \times \ldots \times 9$ (k times) combinations.
    Therefore, the time complexity of the brute-force search algorithm is $O(9^k)$.
    The worst-case scenario is that algorithm needs to explore all possible combinations, leading to the $O(9^{81})$ time complexity.

    \item \textbf{Backtracking Search Algorithm} \cite{backtracking_ref} : \\
    This algorithm assigns a number to a cell and immediately checks constraint validity (row, column, and $3 \times 3$ sub-grid). 
    If the partial assignment violates any constraint, it backtracks recursively to the previous step and tries a different value, thereby pruning large invalid sub-trees in the search space. 
    Although the theoretical worst-case time complexity is still $O(9^k)$ (similar to brute-force), the practical performance is dramatically faster because the effective branching factor $b$ is greatly reduced by constraint filtering ($b \ll 9$).
\end{enumerate}

%----------------------------------------------------------------------------------------
% SECTION 2
%----------------------------------------------------------------------------------------
\subsection{Part 1B}
%----------------------------------------------------------------------------------------
\subsubsection{Procedure}
%----------------------------------------------------------------------------------------
\begin{enumerate}
    \item \textbf{CSP Modelling} \\
    The Sudoku grid is modelled as a $9 \times 9$ matrix \texttt{sudoku\_solver.board}.  
    A candidate assignment is validated by \texttt{is\_valid(row, col, num)}, which checks Row, Column, and Subgrid constraints.

    \item \textbf{Input Handling} \\
    The solver accepts \texttt{.csv} files containing a $9 \times 9$ grid.  
    \texttt{load\_from\_csv(filepath)} parses comma-separated rows, interprets \texttt{0}/blank as empty cells, and rejects matrices not equal to $9 \times 9$.
    \begin{minted}[fontsize=\footnotesize,breaklines,linenos,frame=single]{python}
self.board = []
with open(filepath, 'r', encoding='UTF-8') as f:
    reader = csv.reader(f)
    for row in reader:
        index = [int(num.strip()) for num in row if num.strip().isdigit()]
        if len(index) == 9:
            self.board.append(index)
    \end{minted}

    \item \textbf{Backtracking Solver} \\
    Implemented as DFS in \texttt{solve\_algorithm()}:
    \begin{enumerate}
        \item \textit{Variable selection:} scan the grid to locate the next empty cell $V_{i,j}$.
        \item \textit{Value assignment:} try $d \in \{1,\dots,9\}$ sequentially.
        \item \textit{Pruning:} if \texttt{is\_valid()} fails, skip deeper recursion.
        \item \textit{Backtracking:} on failure, reset $V_{i,j}$ to 0 and attempt the next candidate.
    \end{enumerate}
    \begin{minted}[fontsize=\footnotesize,breaklines,linenos,frame=single]{python}
for i in range(9):
    for j in range(9):
        if self.board[i][j] == 0:
            for num in range(1, 10):
                self.steps += 1
                if self.is_valid(i, j, num):
                    self.board[i][j] = num
                    
                    if self.solve_algorithm():
                        return True
                    
                    self.board[i][j] = 0
                    self.backtracks += 1
    \end{minted}

    \item \textbf{Performance Metrics} \\
    \texttt{run\_solver()} records:  
    \begin{itemize}
        \item execution time (via \texttt{time.perf\_counter()}).
        \item number of backtracks.
        \item number of recursive calls.
    \end{itemize}
    \begin{minted}[fontsize=\footnotesize,breaklines,linenos,frame=single]{python}
self.start_time = time.perf_counter()
success = self.solve_algorithm()
end_time = time.perf_counter()
self.execution_time = (end_time - self.start_time) * 1000
    \end{minted}    
\end{enumerate}

%----------------------------------------------------------------------------------------
\subsubsection{Testing Results}
%----------------------------------------------------------------------------------------
\begin{itemize}
    \item \textbf{Methodology} \\
    In order to test the efficiency of the method ``Backtracking with pruning'', I seperate the puzzels into three levels - Easy, Middle and Difficult.
    Specifically, puzzles and its corresponding solutions from each level are provided by \textit{``Sudoku Name''} \cite{sudoku_data_ref}.

    \item \textbf{Result Display} \\
    To facilitate user interaction and clearly visualize the solving process, a graphical interface was implemented using the \textit{PyQt6} framework \cite{pyqt_ref}. 
    The figures below demonstrate the artifact's capability to handle puzzles of varying difficulties, displaying both the initial board configuration and the final calculated solution in a clean grid format.
    \begin{figure}[H]
        \centering
        \begin{minipage}[b]{0.25\textwidth}
            \includegraphics[width=\textwidth]{./img/easy_q.png}
        \end{minipage}
        \begin{minipage}[b]{0.25\textwidth}
            \includegraphics[width=\textwidth]{./img/middle_q.png}
        \end{minipage}
        \begin{minipage}[b]{0.25\textwidth}
            \includegraphics[width=\textwidth]{./img/difficult_q.png}
        \end{minipage}
    \end{figure}

    \begin{figure}[H]
        \centering
        \begin{minipage}[b]{0.25\textwidth}
            \includegraphics[width=\textwidth]{./img/easy_a.png}
        \end{minipage}
        \begin{minipage}[b]{0.25\textwidth}
            \includegraphics[width=\textwidth]{./img/middle_a.png}
        \end{minipage}
        \begin{minipage}[b]{0.25\textwidth}
            \includegraphics[width=\textwidth]{./img/difficult_a.png}
        \end{minipage}
        \caption{Visualisation of the Sudoku Solver Artefact on different difficulty levels}
    \end{figure}

    \item \textbf{Quantitative Analysis}
    \begin{table}[H]
        \centering
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Difficulty} & \textbf{Time (ms)} & \textbf{Recursive Calls} & \textbf{Backtracks} \\ \hline
            Easy & 1.94 ms & 1,836 & 181 \\ \hline
            Middle & 12.61 ms & 14,755 & 1,608 \\ \hline
            Difficult & 91.60 ms & 194,311 & 21,558 \\ \hline
        \end{tabular}
        \caption{Performance Metrics by Difficulty Level}
    \end{table}
\end{itemize}

%----------------------------------------------------------------------------------------
\subsubsection{Theoretical Comparison: Backtracking vs. A* Search}
%----------------------------------------------------------------------------------------
\begin{enumerate}
    \item \textbf{\textit{A*} Search for \textit{Sudoku}} \\
    \textit{Sudoku} puzzle can be defined by \textit{A*} cost function $f(n) = g(n) + h(n)$:
    \begin{equation}
        \begin{cases}
            g(n)~\text{(path cost)} : \text{The~number~of~cells~filled~so~far} \\
            h(n)~\text{(heuristic)} : \text{The~sum~of~domain~sizes~of~all~empty~cells}
        \end{cases}
        \nonumber
    \end{equation}

    \item \textbf{Comparison table}
    \begin{table}[H]
        \centering
        \renewcommand{\arraystretch}{1.2}
        \small
        \begin{tabular}{|p{0.22\linewidth}|p{0.35\linewidth}|p{0.35\linewidth}|}
            \hline
            \textbf{Metrics} & \textbf{Backtracking} & \textbf{\textit{A*} Search} \\ \hline
            \textbf{Data Structure} & DFS (stack) & BFS (priority queue) \\ \hline
            \textbf{Time Taken} & Faster. Low overhead per step allows checking millions of nodes quickly. & Slower. High overhead due to calculating heuristics $h(n)$ and sorting the queue at every step. \\ \hline
            \textbf{Search Steps} & High. May explore many redundant branches before backtracking. & Low. Heuristics guide the search effectively, visiting fewer total nodes. \\ \hline
            \textbf{Memory Usage} & Linear $O(D)$ & Exponential $O(b^d)$ \\ \hline
            \textbf{Failure Case} & Can get stuck in a wrong branch for too long on malicious puzzles. & Likely to crash due to running out of RAM before finding a solution. \\ \hline
        \end{tabular}
        \caption{Backtracking vs. A* Search for \textit{Sudoku} Puzzles}
    \end{table}

    \item \textbf{Analysis of performance}
    \begin{itemize}
        \item \textbf{Efficiency:} Though \textit{A*} visits fewer nodes, the computational cost per node is high due to heuristic calculations and priority queue maintenance. Backtracking checks millions of nodes in milliseconds due to its minimal overhead, resulting in faster overall execution time.
        \item \textbf{Nature of the Problem:} \textit{A*} is optimized for finding the \textit{shortest path} in a graph. However, \textit{Sudoku} is a typical CSP where the solution depth is fixed. We require any valid solution, not the shortest one, making \textit{A*}'s path-optimizing features redundant.
        \item \textbf{Space Complexity:} The exponential memory usage of \textit{A*} makes it impractical for hard puzzles, whereas Backtracking's linear space complexity ensures robustness on any environments.
    \end{itemize}
\end{enumerate}

\newpage

%----------------------------------------------------------------------------------------
\subsection{Part 2 - Automated Planning}
%----------------------------------------------------------------------------------------
\subsubsection{Part 2A: Modelling the Domain}
%----------------------------------------------------------------------------------------
\subsubsection{Part 2B: Modelling the Problems}
%----------------------------------------------------------------------------------------
\subsubsection{Part 2C: Extension}
%----------------------------------------------------------------------------------------
\section{Reflection and Analysis}

%----------------------------------------------------------------------------------------
\section{Conclusion}

\newpage

%----------------------------------------------------------------------------------------
% Reference
%----------------------------------------------------------------------------------------
% \phantomsection % 如果引用跳转位置不准，可以取消这行的注释
\begin{thebibliography}{99}
    \raggedright
    \bibitem{csp_ref}
    Wikipedia contributors. "Constraint satisfaction problem." Wikipedia, The Free Encyclopedia. [Online].
    Available: \url{https://en.wikipedia.org/wiki/Constraint_satisfaction_problem}

    \bibitem{bruteforce_ref}
    GeeksforGeeks. "Brute Force Approach and its Pros and Cons." [Online].
    Available: \url{https://www.geeksforgeeks.org/brute-force-approach-and-its-pros-and-cons/}

    \bibitem{backtracking_ref}
    GeeksforGeeks. "Backtracking Algorithms." [Online].
    Available: \url{https://www.geeksforgeeks.org/backtracking-algorithms/}

    \bibitem{sudoku_data_ref}
    Sudoku Name. "Online Sudoku Puzzles." [Online].
    Available: \url{https://www.sudoku.name/}

    \bibitem{pyqt_ref}
    Riverbank Computing. "PyQt6 Reference Guide." [Online].
    Available: \url{https://www.riverbankcomputing.com/static/Docs/PyQt6/}

\end{thebibliography}

\end{document}