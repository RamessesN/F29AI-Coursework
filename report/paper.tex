\documentclass[12pt,a4paper]{article}

%----------------------------------------------------------------------------------------
% PACKAGES
%----------------------------------------------------------------------------------------
\usepackage[a4paper,margin=25mm]{geometry}
\usepackage{fontspec}
\setmainfont{Times New Roman}

\usepackage{amsmath}
\usepackage{graphicx,float,booktabs,array,multirow,url}
\usepackage{gensymb}
\usepackage[british]{babel}
\usepackage[square,numbers,sort&compress]{natbib}
\usepackage{caption,subcaption}
\usepackage{pgfplots}
\pgfplotsset{compat=1.9}

\usepackage[colorlinks=true,
            linkcolor=blue,
            citecolor=blue,
            urlcolor=blue]{hyperref}

\usepackage{minted}

\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\addtolength{\topmargin}{-2.5pt}

\usepackage{silence}
\WarningFilter{gensymb}{Not defining}

%----------------------------------------------------------------------------------------
% CUSTOM ABSTRACT FORMAT
%----------------------------------------------------------------------------------------
\makeatletter
\renewenvironment{abstract}{
    \begin{center}
        \large\bfseries \abstractname
    \end{center}
    \begin{quote}\small
}{
    \end{quote}
}
\makeatother

%----------------------------------------------------------------------------------------
% USER INFORMATION
%----------------------------------------------------------------------------------------
\newcommand{\studentonename}{Keqin ZHANG}
\newcommand{\studenttwoname}{Yuwei ZHAO}
\newcommand{\studentonenumber}{H00460395}
\newcommand{\studenttwonumber}{H00460398}
\newcommand{\labgroup}{OUC CW1 33}
\newcommand{\labdate}{2025-11-10}
\newcommand{\course}{F29AI - Artificial Intelligence}
\newcommand{\labtitle}{CW1 Report}

%----------------------------------------------------------------------------------------
% TITLE
%----------------------------------------------------------------------------------------
\title{
    \vspace{-1cm}
    \textbf{\labtitle}\\[0.3em]
    \Large \course
}
\author{
    \studentonename~(\studentonenumber)
    \quad
    \studenttwoname~(\studenttwonumber) \\[0.5em]
    \labgroup \quad \labdate
}
\date{}

%----------------------------------------------------------------------------------------
% PAGE STYLE
%----------------------------------------------------------------------------------------
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\labtitle}
\fancyhead[C]{\course}
\fancyhead[R]{\labgroup}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

\setlength{\parindent}{0em}
\setlength{\parskip}{0.75em}

%----------------------------------------------------------------------------------------
% DOCUMENT BODY
%----------------------------------------------------------------------------------------
\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
% SECTION 1
%----------------------------------------------------------------------------------------
\section{Part 1 - \textit{Sudoku} Puzzels}
%----------------------------------------------------------------------------------------
\subsection{Part 1A}
%----------------------------------------------------------------------------------------
\subsubsection{Procedure}
%----------------------------------------------------------------------------------------
\label{subsection:Procedure}
A CSP(constraint satisfaction problem) should involve the following three components: Variables, Domains and Constraints.
Therefore, we can define the Sudoku problem as follows:
\[
\text{Sudoku} = \langle V, D, C \rangle
\]
where
\begin{itemize}
    \item $V$: The set of 81 variables, $V = \{V_{i,j} \mid i,j \in \{1, 2, \ldots, 9\}\}$.
    
    \item $D$: The domain $D_{i,j}$ for each variable $V_{i,j}$ is defined as:
    \begin{itemize}
        \item $D_{i,j} = \{k\}$, if $V_{i,j}$ is a given cell with value $k$.
        \item $D_{i,j} = \{1, 2, \ldots, 9\}$, if $V_{i,j}$ is an empty cell.
    \end{itemize}

    \item $C$: The set of 27 (9 rows + 9 columns + 9 subgrids) all-different constraints:
    \begin{itemize}
        \item $C_{\text{row}}$: For each row $i$, all variables $V_{i, 1}, V_{i, 2}, \ldots, V_{i, 9}$ must have different values.
        \item $C_{\text{col}}$: For each column $j$, all variables $V_{1, j}, V_{2, j}, \ldots, V_{9, j}$ must have different values.
        \item $C_{\text{subgrid}}$: For each $3 \times 3$ subgrid, all 9 variables within that subgrid must have different values.
    \end{itemize}
\end{itemize}

%----------------------------------------------------------------------------------------
\subsubsection{Time Complexity Analysis}
%----------------------------------------------------------------------------------------
\begin{enumerate}
    \item \textbf{Brute-force Search Algorithm:} \\
    For each of the $k$ spaces, there are 9 possible choices of numbers. This results in a total of $9 \times 9 \times \ldots \times 9$ (k times) combinations.
    Therefore, the time complexity of the brute-force search algorithm is $O(9^k)$.
    When the worst-case scenario occurs, the algorithm needs to explore all possible combinations, leading to the $O(9^{81})$ time complexity.

    \item \textbf{Backtracking Search Algorithm:} \\
    It checks the validity of constraints (row, column, and $3 \times 3$ sub-grid) immediately after assigning a number to a cell.
    If a conflict is detected, namely the current partial solution is invalid, the algorithm recursively backtracks to the previous step to try a different number.
    This process effectively prunes large sub-trees of the search space that are known to be invalid.
\end{enumerate}

While the theoretical worst-case time complexity remains $O(9^k)$, which is similar to brute-force, the average-case performance is drastically faster. 
This is because the effective branching factor $b$ becomes significantly smaller than 9 ($b \ll 9$) as the constraints restrict the number of valid choices for each subsequent cell.

%----------------------------------------------------------------------------------------
% SECTION 2
%----------------------------------------------------------------------------------------
\subsection{Part 1B}
%----------------------------------------------------------------------------------------
\subsubsection{Procedure}
%----------------------------------------------------------------------------------------
\begin{enumerate}
    \item \textbf{Problem abstraction \& CSP modelling} \\
    As stated in Part~\ref{subsection:Procedure}, the corresponding implementation in code is as follows:
    \begin{itemize}
        \item \texttt{sudoku\_solver.board} : a $9 \times 9$ integer matrix (0 means empty).
        \item \texttt{is\_valid(row,col,num)} : enforces the three constraint types for a tentative assignment.
    \end{itemize}

    \item \textbf{Input format preset} \\
    Implement robust input routines that accept \texttt{.csv} formatted $9 \times 9$ grids.
    It needs to read rows with comma separation, convert each token to int, accept 0 or blank as empty.

    In our code base this is the method \texttt{load\_from\_csv(filepath)}. Validate that the parsed grid has $9~\text{rows} \times 9~\text{columns}$, otherwise throw / report an error.

    \item \textbf{Core solver build} \\
    The core algorithm implements a Depth-First Search(DFS) based Backtracking strategy. The implementation logic within the method \texttt{solve\_algorithm()} proceeds as follows:
    \begin{enumerate}
        \item \textbf{Select variables} \\
        The solver iterates through the grid coordinates to identify the first unassigned variable \(V_{i,j}\).

        \item \textbf{Assign values} \\
        For the selected empty cell, the algorithm sequentially attempts to assign values \(d \in \{1, \dots, 9\}\).

        \item \textbf{Carry out prune} \\
        Before finalizing an assignment, the \texttt{is\_valid()} function checks if the assignment violates any Row, Column, or Subgrid constraints. 
        If a violation is detected, the branch is pruned immediately, which means there will be no further recursion occurs for that value.
        
        \item \textbf{Backtracking}
        \begin{itemize}
            \item If the assignment is valid, the state is updated and the function calls itself recursively to solve the rest of the board.
            \item If the recursive call returns \texttt{True}, the solution is propagated up the stack.
            \item If the recursive call returns \texttt{False}, the algorithm performs a backtrack - reset \(V_{i,j}\) to 0 and proceed to try the next value in the domain.
        \end{itemize}
    \end{enumerate}

    \item \textbf{Relevant Metrics Print}
    \begin{itemize}
        \item \textbf{Execution Time:} Measured using \texttt{time.perf\_counter()} in milliseconds to evaluate real-world speed.
        \item \textbf{Backtracks:} Counters incremented whenever the solver hits a dead end and must reverse an assignment. This metric serves as a proxy for the size of the search space explored.
        \item \textbf{Recursive Calls \& Steps:} Tracks the depth and total operations of the search tree.
    \end{itemize}
    These metrics are encapsulated in the \texttt{run\_solver()} wrapper method, separating the measurement logic from the core recursive algorithm.
\end{enumerate}

%----------------------------------------------------------------------------------------
\subsubsection{Testing Results}
%----------------------------------------------------------------------------------------
\begin{itemize}
    \item \textbf{Methodology} \\
    In order to test the efficiency of the method ``Backtracking with pruning'', I seperate the puzzels into three levels - Easy, Middle and Difficult.
    Specifically, puzzles and its corresponding solutions from each level are provided by \href{https://www.sudoku.name/index.php?ln=cn&puzzle_num=&play=1&difficult=4&timer=&time_limit=0&killer_sudoku=0}{Sudoku Name}.

    \item \textbf{Result Display} \\
    \begin{figure}[H]
        \centering
        \begin{minipage}[b]{0.25\textwidth}
            \includegraphics[width=\textwidth]{./img/easy_q.png}
        \end{minipage}
        \begin{minipage}[b]{0.25\textwidth}
            \includegraphics[width=\textwidth]{./img/middle_q.png}
        \end{minipage}
        \begin{minipage}[b]{0.25\textwidth}
            \includegraphics[width=\textwidth]{./img/difficult_q.png}
        \end{minipage}
    \end{figure}

    \begin{figure}[H]
        \centering
        \begin{minipage}[b]{0.25\textwidth}
            \includegraphics[width=\textwidth]{./img/easy_a.png}
        \end{minipage}
        \begin{minipage}[b]{0.25\textwidth}
            \includegraphics[width=\textwidth]{./img/middle_a.png}
        \end{minipage}
        \begin{minipage}[b]{0.25\textwidth}
            \includegraphics[width=\textwidth]{./img/difficult_a.png}
        \end{minipage}
        \caption{Puzzles with increasing levels}
    \end{figure}

    \item \textbf{Quantitative Analysis}
    \begin{table}[H]
        \centering
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Difficulty} & \textbf{Time (ms)} & \textbf{Backtracks} & \textbf{Recursive Calls} \\ \hline
            Easy & 1.94 ms & 1,836 & 181 \\ \hline
            Middle & 12.61 ms & 14,755 & 1,608 \\ \hline
            Difficult & 91.60 ms & 194,311 & 21,558 \\ \hline
        \end{tabular}
        \caption{Performance Metrics by Difficulty Level}
    \end{table}
\end{itemize}

%----------------------------------------------------------------------------------------
\subsubsection{Theoretical Comparison: Backtracking vs. A* Search}
%----------------------------------------------------------------------------------------
\begin{enumerate}
    \item \textbf{\textit{A*} Search for \textit{Sudoku}} \\
    \textit{Sudoku} puzzle can be defined by \textit{A*} cost function $f(n) = g(n) + h(n)$:
    \begin{equation}
        \begin{cases}
            $g(n)$~\text{(path cost)} : \text{The~number~of~cells~filled~so~far} \\
            $h(n)$~\text{(heuristic)} : \text{The~sum~of~domain~sizes~of~all~empty~cells}
        \end{cases}
        \nonumber
    \end{equation}

    \item \textbf{Comparison table}
    \begin{table}[H]
        \centering
        \renewcommand{\arraystretch}{1.2}
        \small
        \begin{tabular}{|p{0.22\linewidth}|p{0.35\linewidth}|p{0.35\linewidth}|}
            \hline
            \textbf{Metrics} & \textbf{Backtracking} & \textbf{\textit{A*} Search} \\ \hline
            \textbf{Data Structure} & DFS (stack) & BFS (priority queue) \\ \hline
            \textbf{Time Taken} & Faster. Low overhead per step allows checking millions of nodes quickly. & Slower. High overhead due to calculating heuristics $h(n)$ and sorting the queue at every step. \\ \hline
            \textbf{Search Steps} & High. May explore many redundant branches before backtracking. & Low. Heuristics guide the search effectively, visiting fewer total nodes. \\ \hline
            \textbf{Memory Usage} & Linear $O(D)$ & Exponential $O(b^d)$ \\ \hline
            \textbf{Failure Case} & Can get stuck in a wrong branch for too long on malicious puzzles. & Likely to crash due to running out of RAM before finding a solution. \\ \hline
        \end{tabular}
        \caption{Backtracking vs. A* Search for \textit{Sudoku} Puzzles}
    \end{table}

    \item \textbf{Analysis of performance}
    \begin{itemize}
        \item \textbf{Efficiency:} Though \textit{A*} visits fewer nodes, the computational cost per node is high due to heuristic calculations and priority queue maintenance. Backtracking checks millions of nodes in milliseconds due to its minimal overhead, resulting in faster overall execution time.
        \item \textbf{Nature of the Problem:} \textit{A*} is optimized for finding the \textit{shortest path} in a graph. However, \textit{Sudoku} is a typical CSP where the solution depth is fixed. We require any valid solution, not the shortest one, making \textit{A*}'s path-optimizing features redundant.
        \item \textbf{Space Complexity:} The exponential memory usage of \textit{A*} makes it impractical for hard puzzles, whereas Backtracking's linear space complexity ensures robustness on any environments.
    \end{itemize}
\end{enumerate}

\newpage
%----------------------------------------------------------------------------------------
\subsection{Part 2 - Automated Planning}
\subsubsection{Part 2A: Modelling the Domain}
\subsubsection{Part 2B: Modelling the Problems}
\subsubsection{Part 2C: Extension}

%----------------------------------------------------------------------------------------
\section{Reflection and Analysis}

%----------------------------------------------------------------------------------------
\section{Conclusion}

\newpage

%----------------------------------------------------------------------------------------
% Source Code
%----------------------------------------------------------------------------------------
\pagestyle{empty}
\section{Source Code}
\label{section:source_code}
\begin{itemize}
    \item \textbf{Part1 - \textit{sudoku\_solver.py}}
    \label{item:sudoku_solver}
    \begin{minted}[fontsize=\footnotesize,breaklines,linenos,frame=single]{python}
import csv
import time

class SudokuSolver:
    def __init__(self):
        self.board = []
        # Relevant metrics
        self.steps = 0            # Total number of steps
        self.recursive_calls = 0  # Recursive calls
        self.backtracks = 0       # Backtracks
        self.start_time = 0
        self.execution_time = 0

    def load_from_csv(self, filepath):
        self.board = []
        try:
            with open(filepath, 'r', encoding='UTF-8') as f:
                reader = csv.reader(f)
                for row in reader:
                    # Converts the string to an integer, handling possible whitespace
                    index = [int(num.strip()) for num in row if num.strip().isdigit()]
                    if len(index) == 9:
                        self.board.append(index)
            
            if len(self.board) != 9:
                raise ValueError("Invalid row count in CSV")
            
            print(f"[Succeed] File loaded: {filepath}")
            return True
        except Exception as e:
            print(f"[Error] File loading failed: {e}")
            return False

    def is_valid(self, row, col, num):
        # Row check
        for x in range(9):
            if self.board[row][x] == num:
                return False

        # Column check
        for x in range(9):
            if self.board[x][col] == num:
                return False

        # 3x3 box check
        start_row = row - row % 3
        start_col = col - col % 3
        for i in range(3):
            for j in range(3):
                if self.board[i + start_row][j + start_col] == num:
                    return False
        
        return True

    def solve_algorithm(self):
        self.recursive_calls += 1
        
        for i in range(9):
            for j in range(9):
                if self.board[i][j] == 0:
                    for num in range(1, 10):
                        self.steps += 1
                        # If invalid, prune it
                        if self.is_valid(i, j, num):
                            self.board[i][j] = num
                            
                            if self.solve_algorithm():
                                return True
                            
                            # Backtracking
                            self.board[i][j] = 0
                            self.backtracks += 1
                    
                    return False
        return True

    def run_solver(self):
        self.steps = 0
        self.recursive_calls = 0
        self.backtracks = 0
        
        self.start_time = time.perf_counter()
        
        success = self.solve_algorithm()
        
        end_time = time.perf_counter()
        self.execution_time = (end_time - self.start_time) * 1000
        
        return success

    def print_metrics(self):
        print("\n")
        print(f"Execution Time: {self.execution_time:.4f} ms")
        print(f"Total Steps (Attempts): {self.steps}")
        print(f"Recursive Calls: {self.recursive_calls}")
        print(f"Backtracks: {self.backtracks}")
        print("\n")
    \end{minted}
\end{itemize}

\newpage

%----------------------------------------------------------------------------------------
% Reference
%----------------------------------------------------------------------------------------
\section{Reference}
\label{section:reference}
\begin{verbatim}
@ CSP 相关
<https://en.wikipedia.org/wiki/Constraint_satisfaction_problem>
<https://www.geeksforgeeks.org/artificial-intelligence/constraint-satisfaction-problems-csp-in-artificial-intelligence/>

@ Brute-force
<https://en.wikipedia.org/wiki/Brute-force_search>
<https://www.geeksforgeeks.org/dsa/brute-force-approach-and-its-pros-and-cons/>

@ Backtracking
<https://en.wikipedia.org/wiki/Backtracking>
<https://www.geeksforgeeks.org/dsa/backtracking-algorithms/>

@ pyqt 相关
1. <https://www.riverbankcomputing.com/static/Docs/PyQt6/>
2. <https://www.runoob.com/python3/python-pyqt.html>
3. <https://blog.csdn.net/u012117917/article/details/41604711>
4. <https://zhuanlan.zhihu.com/p/390192953>

@ 

See Resources on \href{https://github.com/ZhangKeqin0307/couresework1.git}{git@github.com:ZhangKeqin0307/couresework1.git}.
\end{verbatim}

\end{document}